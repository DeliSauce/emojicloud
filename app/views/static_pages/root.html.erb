<!-- <main id="root">
  <h1>Emojicloud</h1>
  <p>Emojicloud is a visualization of emojis from tweets posted at a certain time or location. Similar to word cloud, more common emojis will be larger in size. Through this visualization, users will be able to get the general sense of how the public is feeling at a certain time and location.</p>
</main> -->

<!DOCTYPE html>
<html id="root">
<script src="https://cdn.jsdelivr.net/emojione/2.2.7/lib/js/emojione.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/emojione/2.2.7/assets/css/emojione.min.css"/>
<!-- <script src='http://cdn.jsdelivr.net/emojione/2.1.4/lib/js/emojione.min.js'></script>
<link rel='stylesheet prefetch' href='http://cdn.jsdelivr.net/emojione/2.1.4/assets/css/emojione.min.css'> -->
  <head>
    <meta charset="utf-8">
    <title></title>
    <style media="screen">
      body {
        display: flex;
        width: 100%;
      }
      #tweet-container {
        width: 200;
        height: 200;
        border: red 1px solid;
        display:
      }
    </style>
  </head>
  <body>
    <svg id="cloud">
    </svg>
    <div id="tweet-container">
        TWEETS
        <div id="divTweets">
        </div>
    </div>
    <!-- <svg id="tweets">
    </svg> -->
    <!-- <script src="./emoji_cloud.js"></script> -->
  </body>
</html>
<script src='https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.16/d3.min.js'></script>
<script>
// import emojione from 'emojione';
// import * as d3 from 'd3';
// let emojis = {
//   '1f60f': 44, '1f61f': 2, '1f62f': 25, '1f63f': 33, '1f64f': 55,
//   '1f10f': 44, '1f11f': 2, '1f12f': 25, '1f13f': 33, '1f14f': 55,
//   '1f20f': 44, '1f21f': 2, '1f22f': 25, '1f23f': 33, '1f24f': 55,
//   '1f30f': 44, '1f31f': 2, '1f32f': 25, '1f33f': 33, '1f34f': 55,
//   '1f40f': 44, '1f41f': 2, '1f42f': 25, '1f43f': 33, '1f44f': 55
// };
//
// let unicodeTest2 = {
//   '😄': randomSize(), '😁': randomSize()
// };
let emojis;

let unicodeTest5;
let unicodeTest6

// TODO need to make this is synchronous. Also issues with unicode characters not being strings
d3.json('/api/emojis', function(data) {
  // unicodeTest5 = data.emojis;
  // unicodeTest5 = {'😄': 29};
  // unicodeTest6 = data.emojis;

  // console.log(unicodeTest5, data);
  // console.log(temp);
  emojis = getEmojis(data.emojis);
  console.log(data.emojis);
  // Object.keys(unicodeTest6).forEach((moj) => console.log(moj));
  addPerson();

})
// unicodeTest5 = {'😄': 29};

// var unicodeTest3 = {':grinning:': randomSize(), ':banana:': randomSize(), ':grin:': randomSize(), ':joy:': randomSize(), ':smiley:': randomSize(), ':smile:': randomSize(), ':sweat_smile:': randomSize(), ':laughing:': randomSize(), ':tomato:': randomSize(), ':wink:': randomSize(), ':blush:': randomSize(), ':slight_smile:': randomSize(), ':upside_down:': randomSize(), ':relaxed:': randomSize(), ':yum:': randomSize(), ':relieved:': randomSize(), ':heart_eyes:': randomSize(), ':kissing_heart:': randomSize(), ':kissing:': randomSize()};
//
// var unicodeTest4 = {':grinning:': randomSize(), ':banana:': randomSize()};
// function randomSize() {
//   let min = 15;
//   let max = 70;
//   return Math.random() * (max - min) + min;
// }

// function scaleEmoji(num) {
//   let
//   let min = 40;
//   let max = 100;
//
//   // num * emojiScalingFactor
//   return num;
// }

function getEmojis(emojis) {
  let totalCount = 0;
  let minCount;
  let maxCount;
  // Object.values(emojis).reduce((a,b) => a + b);
  Object.values(emojis).forEach((el, idx) => {
    totalCount += (el * el);
    if (idx === 0) {
      minCount = el;
      maxCount = el;
    } else {
      if (el < minCount) minCount = el;
      if (el > maxCount) maxCount = el;
    }
  });
  console.log(totalCount, minCount, maxCount);

  let emojiScalingFactor = getScalingFactor(totalCount, minCount, maxCount);

  console.log(totalCount);
  return Object.keys(emojis).map(function(emoji) {
    return {
      emojiType: emoji,
      // imageUrl: emojione.shortnameToImage(emoji).match(/src="(.*)"/)[1],
      imageUrl: emojione.unicodeToImage(emoji).match(/src="(.*)"/)[1],
      count: emojis[emoji] * emojiScalingFactor
    };
  });
}

function getScalingFactor(total, min, max) {
  let factor = width * height / total;
  console.log(factor, width, height, total);
  return factor
}

// Object.keys(emojis).map(function(emoji) {
//   return {
//     url: 'http://cdn.jsdelivr.net/emojione/assets/png/' + emoji + '.png?v=2.1.4',
//     weight: emojis[emoji]
//   };
// });
var width = 500;
var height = 500;
var nodes = [];
var links = [];
var svg = d3.select("#cloud")
    .attr("width", width)
    .attr("height", height)
    .style("border", "1px solid black");
// var tweets = d3.select("#tweets")
//     .attr("width", 300)
//     .attr("height", 300)
//     .style("border", "1px solid black");
var node = svg.selectAll(".node");
var force = d3.layout.force()
    .nodes(nodes)
    .links(links)
    .size([width, height])
    .on("tick", tick)
    .linkStrength(0.8)
    .friction(0.9)
    .linkDistance(40)
    .charge(-400)
    .gravity(0.1)
    .theta(0.8)
    .alpha(0.1);



function start() {
    node = node.data(force.nodes(), function(d) {
        return d.index;
    });
    node.enter()
        .append("svg:image")
        .attr("xlink:href", function (d) {
          return d.imageUrl;
        })
        // .attr("width", function (d) {
        //   return d.width;
        // })
        .attr("height", function (d) {
          return d.count; // scaleEmoji(d.count);
        })
        .attr("class", function(d) {
            return "node";
        })
        .attr("emojiType", function(d) {
            return d.emojiType;
        });
        // .on("mouseover", fade(.1, true));
        // .attr("width", 120)
        // .attr("height", 120)
    node.exit().remove();
    node.call(force.drag)
        .on("mousedown", function() {
            console.log(node);
            d3.event.stopPropagation();
        });
    node.on("mousedown", function() {
            console.log(node);
        });
    node.on("mouseover", function(d) {
      console.log(d.emojiType);
      updateSidebar(d.emojiType);
      // node.attr("height", function(d) {
      //   return 100;
      // });
    });
    force.start();
    // console.log(d3);
}
let tweets = document.getElementById('divTweets');
function updateSidebar(emojiType){
  // {':grinning:': ['Hey buddy', 'Fun times'] }
  tweets.innerHTML = emojiType;
}
function tick(e) {
    node.attr("x", function(d) {
            if (d.x >= width - (d.count)) {
              return width - (d.count);
            } else if (d.x <= 0) {
              return 0;
            } else {return d.x;}
        })
        .attr("y", function(d) {
                if (d.y >= height - (d.count)) {
                  return height - (d.count);
                } else if (d.y <= 0) {
                  return 0;
                } else {return d.y;}
            });
        // .each(cluster(10 * e.alpha * e.alpha))
        // .each(collide(.5))
}
let padding = 15, // separation between same-color circles
    clusterPadding = 16, // separation between different-color circles
    maxRadius = 12;
function getInitialPosition() {
  var position = {};
  var dir = Math.floor(Math.random() * 4);
  if (dir === 1) {
    position.x = Math.random() * width;
    position.y = 0;
  } else if (dir === 2) {
    position.x = Math.random() * width;
    position.y = height;
  } else if (dir === 3) {
    position.x = 0;
    position.y = Math.random() * height;
  } else if (dir === 4) {
    position.x = width;
    position.y = Math.random() * height;
  }
  return position;
}
var delay = 10;

function addPerson() {
    var feeling = emojis.pop();
    var position = getInitialPosition();
    // feeling.x = width/2;
    // feeling.y = width/2;
    // feeling.x = position.x;
    // feeling.y = position.y;
    nodes.push(feeling);
    start();
    if (emojis.length > 0) {
      setTimeout(function () {
        addPerson();
      }, delay);
        delay -= .1;

    }
}
// addPerson();
 </script>
